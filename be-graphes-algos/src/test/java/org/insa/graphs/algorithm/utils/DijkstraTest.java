package org.insa.graphs.algorithm.utils;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import org.insa.graphs.model.Arc;
import org.insa.graphs.model.Graph;
import org.insa.graphs.model.Node;
import org.insa.graphs.model.Path;
import org.insa.graphs.model.RoadInformation;
import org.insa.graphs.model.RoadInformation.RoadType;
import org.junit.BeforeClass;
import org.junit.Test;
import org.insa.graphs.algorithm.ArcInspector;
import org.insa.graphs.algorithm.ArcInspectorFactory;
import org.insa.graphs.algorithm.shortestpath.BellmanFordAlgorithm;
import org.insa.graphs.algorithm.shortestpath.DijkstraAlgorithm;
import org.insa.graphs.algorithm.shortestpath.ShortestPathData;
import org.insa.graphs.algorithm.shortestpath.ShortestPathSolution;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.FileInputStream;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;


import org.insa.graphs.model.io.BinaryGraphReader;
import org.insa.graphs.model.io.BinaryPathReader;
import org.insa.graphs.model.io.GraphReader;
import org.insa.graphs.model.io.PathReader;

public class DijkstraTest {

    // Small graph use for tests
    private static Graph graph;
    
    @SuppressWarnings("unused")
    // Path to the .mapgr file used for testing
    private static String map_carre,map_insa,map_toulouse;   
    
    @SuppressWarnings("unused")
    //Readers to extract the graph from the files
    private static GraphReader reader_carre, reader_insa, reader_toulouse;
    
    @SuppressWarnings("unused")
    //Graphs extracted from the maps
    private static Graph graph_carre, graph_insa, graph_toulouse;
    
    @SuppressWarnings("unused")
    //Data to be fed to the algorithms
    private static ShortestPathData data_carre, data_insa, data_toulouse;
    
        
    @BeforeClass
    public static void initAll() throws IOException {

    	 map_carre = "/home/work/Repositories/be-graphe/maps/carre.mapgr";
    	 map_insa = "/home/work/Repositories/be-graphe/maps/insa.mapgr";
    	 map_toulouse = "/home/work/Repositories/be-graphe/maps/toulouse.mapgr";
    	 
    	 //Extracting the graph from carre.mapgr
    	 
    	 reader_carre = new BinaryGraphReader(new DataInputStream(new BufferedInputStream(new FileInputStream(map_carre)))); 
    	 graph_carre = reader_carre.read();
    	 
    	 
    	 
    }
    
    private static int getRandomDoubleBetweenRange(int min, int max){
        int x = (int) (((Math.random()*((max-min)+1))+min));
        return x;
    }
     
    @Test
    public void test_no_filter_length() {
    	test(graph_carre,0);
    }
    
    @Test
    public void test_car_time() {
    	test(graph_carre,1);
    }
    
    @Test
    public void test_no_filter_time() {
    	test(graph_carre,2);
    }
        
    @Test
    public void test_car_length() {
    	test(graph_carre,3);
    }
    
    @Test
    public void test_pedestrian_bike_time() {
    	test(graph_carre,4);
    }
    
    private void test(Graph graph, int Mode){  	
    	
	    /*
	   	  * All the arc inspecting modes have to be tested : 
	   	  * 0 = no filter length, 1 = cars and length
	   	  * 2 = no filter time , 3 = cars and time , 4 = pedestrian and bicycle (non-private roads) time
	   	  */
	   	 int nb_nodes = graph.size();

		    	 for(int i = 0 ; i < 50 ; i++) {
		    		 
		    		 //Start and Destination nodes IDs randomly generated using Math.random 
		    		 int start_id = getRandomDoubleBetweenRange(0,nb_nodes);
		    		 int destination_id = getRandomDoubleBetweenRange(0,nb_nodes);
		    		 
		    		 //Extracting start and destination nodes from the graph
		    		 Node start_node = graph_carre.getNodes().get(start_id);
		    		 Node destination_node = graph_carre.getNodes().get(destination_id);
		    		 
		    		 //Selecting the arc filtering mode (test parameter)
		    		 ArcInspector filter = ArcInspectorFactory.getAllFilters().get(Mode);
		    		 
		    		 data_carre = new ShortestPathData(graph_carre,start_node,destination_node,filter); 


		    		//Running and saving the solution generated by the different algorithms
		    	    DijkstraAlgorithm algo_dijkstra = new DijkstraAlgorithm(data_carre);
		    	    ShortestPathSolution solution_dijkstra = algo_dijkstra.run();
		    	    	
		    	    BellmanFordAlgorithm algo_BF = new BellmanFordAlgorithm(data_carre);
		    	    ShortestPathSolution solution_BF = algo_BF.run();
		    	    	
		    	    //Comparing the tested algorithm to BF (the reference)
		    	    assertEquals(solution_BF, solution_dijkstra);
		    		 
		    	 }
		    	 
	   	 }
    	

    @Test
    private void test_Invalid(char Mode) {
    	//TODO 
    	assertTrue(true);
    }
    
    @Test
    private void test_Infeasible(char Mode) {
    	//TODO 
    	assertTrue(true);
    }
    
    @Test
    private void test_SingleNode(char Mode) {
    	//TODO 
    	assertTrue(true);
    }
    
    @Test
    private void test_Valid(char Mode) {
    	//TODO 
    	assertTrue(true);
    }
    
    
        
}
